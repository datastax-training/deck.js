= Sensor Data Use Case
Artem Chebotko, Joe Chu, Tanya Gallagher, Jamie King
:backend: deckjs
:deckjs_theme: datastax
:deckjs_transition: fade
:goto:
:menu:
:imagesdir: ./images

== What are sensor applications?

* Agriculture
* Environment and natural resources
* Healthcare and wellness
* Homeland security
* Military
* Monitoring and control
* Retail
* Robotics and automation
* Smart home/office/auto
* Telematics
* Utilities

== Sensor data: use case introduction

* Data description
** Multiple sensor networks are deployed over non-overlapping regions
** A sensor network is identified by a unique name
** A sensor belongs to exactly one network
** A sensor has a unique identifier, location, and characteristics (e.g. accuracy, cost, manufacturing date) 
** A sensor records new measurements (e.g. temperature, humidity, pressure) every second

* [emphasis]#*We will focus on temperature in this example*#

== Sensor data: use case introduction

* Application queries
** Q~1~: Find information about all networks; order by name (ASC)
** Q~2~: Find hourly average temperatures for all sensors in a specified network for a specified date range; order by date (DESC) and hour (DESC)
** Q~3~: Find information about all sensors in a specified network
** Q~4~: Find raw measurements for a particular sensor on a specified date; order by timestamp (DESC)

== Sensor data: conceptual data model

image::conceptualdatamodel.svg[]
* Keys
** [blue]#*has*#: sensor id
** [blue]#*records*# and [blue]#*Measurement*#: sensor id, timestamp, parameter

== Sensor data: application workflow

image::applicationworkflow.svg[]

== Sensor data: logical data model

image::logicaldatamodel.svg[]

== Sensor data: analysis

* Partition size
image:logical_networks.svg[float="right"]
** Networks 
*** One small partition
** Sensor_by_network
image:logical_sensors_by_network.svg[float="right"]
*** Assume at most 1,000 sensors per network
*** Manageable partitions
** Temperatures_by_sensor
image:logical_temperatures_by_sensor.svg[float="right"]
*** 86,400 seconds per day
*** Manageable partitions

== Sensor data: analysis

image::logical_temperatures_by_network.svg[float="right"]

* Partition size
** Temperatures_by_network
*** Assume at most 1,000 sensors per network
*** 24 hours per day

[options="step"]
--
*** [emphasis]#*365 days*# (1 year)
**** 365 x 24 x 1000 = 8,765,000
**** Large partition
--

[options="step"]
--
*** [emphasis]#*30 days*# (1 month)
**** 30 x 24 x 1000 = 720,000
**** Somewhat manageable
--

[options="step"]
--
*** [emphasis]#*7 days*# (1 week)
**** 7 x 24 x 1000 = 168,000
**** Manageable partitions
--

== Sensor data: analysis
* Duplication
** How many times is [emphasis]#*region*# stored per network?
** How many times is [emphasis]#*location*# stored per sensor?

|===

| image:logical_networks.svg[] | image:logical_sensors_by_network.svg[] | image:logical_temperatures_by_network.svg[]

|===

== Sensor data: physical data model

image::physicaldatamodel.svg[]

== Sensor data: physical data model

****

image::physical_networks.svg[float="right"]

  CREATE TABLE networks (
      dummy TEXT,
      name TEXT,
      region TEXT,
      description TEXT,
      n_sensors INT,
      PRIMARY KEY (dummy, name)
  );

  -- Q1
  SELECT * 
  FROM networks;

****

== Sensor data: physical data model

****

image::physical_temperatures_by_network.svg[float="right"]

  CREATE TABLE temperatures_by_network (
      network TEXT,
      week INT,
      date_hour TIMESTAMP,
      sensor TEXT,
      avg_temp FLOAT,
      location TEXT,
      region TEXT STATIC,
      PRIMARY KEY ( (network, week), date_hour, sensor)
  )
  WITH CLUSTERING ORDER BY (date_hour DESC, sensor ASC);

  -- Q2
  SELECT * FROM temperatures_by_network
  WHERE network = ? AND week = ?
        AND date_hour >= ? AND date_hour <= ?; 

****

== Sensor data: physical data model

****

image::physical_sensors_by_network.svg[float="right"]

  CREATE TABLE sensors_by_network (
      network TEXT,
      sensor TEXT,
      location TEXT,
      chracteristics MAP<TEXT,TEXT>,
      PRIMARY KEY (network, sensor)
  );

  -- Q3
  SELECT * FROM sensors_by_network
  WHERE network = ?; 

****

== Sensor data: physical data model

****

image::physical_temperatures_by_sensor.svg[float="right"]

  CREATE TABLE temperatures_by_sensor (
      sensor TEXT,
      date TIMESTAMP,
      ts TIMESTAMP,
      temp FLOAT,
      PRIMARY KEY ((sensor, date), ts)
  )
  WITH CLUSTERING ORDER BY (ts DESC);

  -- Q4
  SELECT * FROM temperatures_by_sensor
  WHERE sensor = ? AND date = ?; 

****

[canvas-image="images/slidebackground.jpg"]
== End of presentation
